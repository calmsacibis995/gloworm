

68k30 SBC:

	* really need to look up the memory interface...  Some other boards are using GALs for the A1/A0, SIZ1-0, and DTACK1-0 logic
	* the idea for rev1 is to clock it slow and have limited features.  1M Flash, 1M SRAM would be sufficient, but if it's not too much trouble to have more...


Operating System:

	* add debugging/tracing support for debugging issues like below
	* there's an issue which seems to affect the shell program when run as a normal process, as opposed to the builtin copy the kernel is compiled with.  It seems
	  to affect both the copy sent over serial and the copy transfered by compact flash.  When running commands inside the shell (that's running inside the shell
	  started during boot), it will sometimes say "Command not found" or hang or crash.  Sometimes it'll work without an issue, but sometimes the second command you
	  invoke will hang the system.  This doesn't seems to affect the builtin shell.  Could it be a stack overflow problem? A stack check didn't seem to turn anything up.
	  It seems to happen consistently after starting the shell first thing when booted, and running `ls`, followed by `echo hey`, which halts the system.  The command
	  not found condition seems to be less predictable.  These could be different issues
	  I can't seem to reproduce this anymore, except with the sh.bin binary on the flash card from a long time ago

	* there is an issue running the shell on linux related to the setting the process group

	* for tty subsystem, you need a way for the tty driver to tell the serial driver that it's opened the serial driver and so the bottom half for the tty should be requested.
	  and you need a way to prevent the current process suspension when the tty subsystem is processing the input, since it will handle that... but serial still needs to suspend
	  procs that are reading directly... (How worth it is to have separate driver entries for tty/serial vs using the line discipline to read directly)
	* add brk/sbrk/stack guard protection
	* if you're going to use a unified process segment, then you should probably fix the allocator to merge freed blocks, and/or use a separate heap for the kernel vs process space?
	* make user programs optionally initialize the heap in a default start routine, and make the heap able to grow (once you have brk/sbrk)
	* refactor to allow commands to be individually compiled to elfs, and loaded onto the memory card, and executed like normal processes
	* make a PIE format that can be loaded and executed
	* try porting a simple command, and then something more complex, maybe awk or something as a big target

	* make the bootloader a bit smaller??
	* make a /dev/flash0 device or /dev/rom0 device in the mem.c driver, possibly even with a partition table and bootloader, that can be mounted read only
	* write the bootloader into rom somewhere, such that it can boot from rom or the compact flash
	* how can you pass arguments into the kernel from the boot loader?  Can you make it bootable from either a disk image in flash, or a disk image on the CF card?
	* make init be a separate file loaded from disk and executed
	* make init relaunch shell if the initial one is killed
	* make a recipe to create a tar file which can be sent and expanded into the ram disk after the kernel has been booted
	* can you make it easily possible to boot the system only from a single file, or to boot using the compact flash, so I can have a more full system on the disk ready


	* should filedesc be put into fs/?
	* should the timer stuff in proc be moved somewhere else?
	* should you make a lib subdir, and put unistd at the top?
	* move as much inline assembly into a redirectable asm directory: kernel/syscall.h, and interrupts.h/interrupts.c are the last places... interrupt code will need it's own arch dir


	* add more info to the ps command, which is now available in the stat file
	* commands like mv and cp require the second arg to include the new filename, but if the arg is a dir, it should append the file's name
	* add updating of fs timestamps, should they be in vfs or inside individual implementations?
	* add support for umask, and add a mode filter somewhere: (mode & ~umask & 0777)
	* when there's a trailing / to rm or mkdir, it will create something weird
	* add checks for errors in the serial transfer? (I don't think we're handling a frame error or buffer overrun, which could happen if interrupts are turned off for too long)
	* need to set the ctty in the init process somehow (other systems set it as a special case when opening a tty)
	* signals like SIGTTOU are supposed to be sent sometimes instead of returning success or failure
	* make it possible to sync disk data to flash (possibly even to write new monitor roms to flash as well)



	* add network syscalls for local IPC (unix file, sockets, maybe even fifos?)
	* make a device-independent tty subsystem
	* add pipe setup to command evaluation
	* implement getopt, and add flags to commands
	* add fifos (should be easy now)
	* implement login system (setuid)
	* make use of 68k's supervisor and user mode (you might not have to switch stacks if you do, since it would use a different stack register)

	* add commands: rmdir, pwd, dd, chown
	* add the & (run in background) option to the shell
	* implement fg/bg somehow... it would be builtin to the shell and would require job control stuff...
	* add up/down arrow processing to the shell (easy without cooked input, but how would it be done with...)
	* to stdlib, add: fprintf, fscanf, scanf, fopen, fclose, fgetpos, fseek, feof, fread, fwrite
	* implement gmtime() and make the time command return a formatted time
	* rewrite the math functions to use fewer registers, and cover the 32 bit divide by 32 bit number case

	* the directory size value in the inode isn't working the best.  There is no dir size shrinking yet either
	* make it possible to have root procfs files instead of requiring all top level files to be process numbered files
	* add check to vfs_link() for loops
	* implement symlinks in minixfs
	* implement links for mallocfs
	* minixfs, implement versions 2 and 3



	* should there be something that periodically syncs data to disk?
	* should you refactor the header files in minixfs implementation into actual c files, with a common header to declare the functions?
	* could I use the queue node to add procs to a free list, instead of iterating over all the procs when creating a new one
	* should there be a lighter weight task type, instead of processes, so that you can service interrupt processing without a bunch of wasted memory
	* move interrupt and syscall_entry code into proc??
	* move the math functions in libc to arch/68k
	* do you need to add variable sized buffers/blocks into bufcache? (yes)
	* can you change the fd allocator, such that calling it twice will return 2 different fds, even though they aren't reserved until set
	  (ie. store the last allocated fd, but it has to be in the process struct)
	* should there be a vnode op to fill in the statbuf struct, or should they be in the vnode?  The 3 values not in the vnode (ino, blksize, blocks)
	* the context switch at the start of an interrupt takes at least 70us.  It is more or less required if we might reschedule a process on exit, which is necessary for the timer
	  interrupt, but if we had the timer and serial on different interrupts (different hardware), we could make the serial ints fast-ints, only saving the 4 scratch registers
	  It *might* be possible to defer the context save until you're certain a reschedule is needed just before exiting, but it would require being very careful during the stack swap



	* in user processes with pre-initialized global variables, if they contain any addresses, the addresses will be relative to 0, and thus not be correct (rather than being relative addresses)

	* remove the execbuiltin syscall, which is temporary until all commands can be executable files

	* look for any bugs that might be caused by a function returning the same vnode as was passed in
	* re-evaluate file permissions checks to make sure they're correct according to posix
	* a slab allocator would maybe help, but I don't think it's as important at the moment
	* you need some tests, but ideally it would use a simple emulator.  Maybe easy68k or something could be used

	* as a note about terminology for pseudoterminals, pts/ptm (slave/master);  it would make more sense for them to be named process-end and device-end, which implies
	  the expected interface to each.   A user process will open the process-end terminal device and communicate with it like any tty.  The emulator or whatever would
	  connect to the other end and act as if it were a terminal device, in place of what would be an actual I/O device like RS-232 or a hardwired keyboard.  I guess the
	  abbreviations might be /dev/ptpX and /dev/ptdX?


Monitor:

	* failure vectors don't point to the correct addresses, from the looks of it

	* there is an issue with load scripts that are an odd number of bytes, and the last byte wont be read/written because the loader operates on words

	* can you have an debugger in the monitor software?  There are trap and breakpoint instructions in the processor for debugging, so if you define an interrupt handler
	  for those, you could have it enter a debugger, that possibly allows single stepping?  I'm not sure how to implement that


68k Single Board Computer:

	* the serial issue turns out to be a problem with the crystal for the serial chip.  It is outputting an inconsistent signal around 100kHz when powered through
	  USB or power supply.  When powered by the arduino, you have to unplug and replug the serial usb cable to make it work, which seems to reset the oscillator.
	  Connecting a 22pF capacitor across the crystal jumpstarts it, but the output is a lot lower on the scope with it connected.  The datasheet says to use 15 and 5pF
	  which is pretty low, and I don't have caps that small.  I have to play with it more, but this seems to be a cap issue more than anything


	* can you add a video/lcd expansion via the expansion connector?  Maybe you could get ends to directly connect it?  Would it be via parallel interface?
	  would you need a PIT 68230 to interface?  How complex are the interfaces of those graphic ones?
	* can you connect an esp01 as a wifi device?  I suppose you could connect it to the other serial port, even though it would be slow


68k Arduino Shield:
	(nothing atm)


68k SMT:
	(nothing atm)


* should you move the Z80 project into it's own repo?

* it might be possible to do a 68030 single board computer, with 74LVC244/245 interfaces to an fpga chip, to provide the glue logic, but it would be a
  lot of surface mount chips, so you'd have to try a few smaller surface mount projects first
* make a surface mount/PLCC version of the 68k-SBC board to test SMT, since the design should work, and some of the memory chips are available as SMT

