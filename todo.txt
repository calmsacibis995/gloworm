

k30-SBC:
	* there is some question of the I/O space, which will be different anyways, so the drivers will have to use different addresses.  It would be nice if the RAM could more easily be
	  variable in size.  This would be ok if you reserved all of 0x00800000 to 0x00FFFFFF for onboard SRAM, and the lower area for I/O and flash, with everything above 0x01000000
	  being on the bus
	* where should the memory and I/O be mapped?  What if you had a bus that only used A24 space like VME allows? (ie. Z280 or something)

	* how are you going to do the dsack stuff?
	* what will you do about interrupts?
	* if you add a dual counter, you can have one for the flash dsack and one for berr, but they should both be configurable as to what the delay will be (or disabled for berr)
	* should you put an OR gate into the RD and WR signals to require DS as well? it's done on KISS but not on Gryphon
	* should you add A16 into the interrupt acknowledge signal, which would distinguish it from a coprocessor or break acknowledge cycle

	* add switches to enable/disable MMU, Cache
	* add switches/jumpers/something to select the delay for buserr and compactflash dsack

	* look into the CIIN signals and stuff
	* it would be nice to keep it as compatible with the existing one at possible, but it probably should be set up more for the future, including having 4MB or 8MB of onboard SRAM
	* I could add headers for a 41612 connector along side the pin headers, with the idea of maybe using this card in a backplane for a single CPU/multi card computer
	  and the bus arbitration stuff can be on the backplane.  The big question is at what point would I need drivers on the bus lines

	* current plan is 2MB: 2 x 16-bit AS6C8016s, and 512KB, 8bit flash using the same AM29F040 chips.  It'll be slow running the flash code, but that's ok because it's expected
	  to load the OS into SRAM, and it uses fewer chips, and it'll be possible to program the flash through the existing supervisor, or to remove it and program it separately
	* the idea for rev1 is to clock it slow and have limited features


Post:
	* I need to elaborate on how I did things, what broke, how I fixed it...  It's a bit too much a list of what I did rather than something helpful

Operating System:

	* something is causing the SLIP serial port to mess up somehow which requires restarting the PC side the setup
	* make the tty68681 driver partially write data... right now it'll suspend if the full request can't be buffered, but it should return the partial number, and the read/write syscalls should do
	  the actual blocking, and then for writing it can rewrite the syscall during the suspend, so that it'll restart in the proper position.  You then need to add resuming to tty
	* when there's a trailing / to rm or mkdir, it will create something weird


	* add timers and retransmissions to tcp
	* try transfering files over tcp, to test the stability of TCP (it should be possible to `nc -l 3904 > tar -x` or something to transfer data)
	* make checksum command for file integrity
	* add a read only mounting mode, such that you know you wont need to sync while also not messing up the CF card
	* should there be something that periodically syncs data to disk?
	* need a function to convert a device number into a device name or device file path. (Could add another driver function pointer for getting the name of a devnum) (add to /proc/mounts)
	* I don't really like the point-of-no-return code in execve().  Is there a way to ensure that wont happen, such as not overwriting the memory segments until the new process is loaded
	* make use of 68k's supervisor and user mode. This requires major changes to the create_context since the entry point can't be put onto the user stack. RTE will pop the ret off the supervisor stack
	* add calculating of cpu runtime


	* add check to vfs_link() for loops
	* do you need to disable triggering of the device-indepedent tty bottom half when the serial device is opened directly?
	* should there be a vnode op to fill in the statbuf struct, or should they be in the vnode?  The only 2 values not in the vnode are blksize, blocks
	* the directory size value in the inode isn't working the best.  There is no dir size shrinking yet either
	* split the boot loader up into multiple parts, so it can be stage loaded
	* how can you make a df command to list how many blocks are free??  That info would need to come from the minix fs-specific code
	* need to set the ctty in the init process somehow (other systems set it as a special case when opening a tty)
	* signals like SIGTTOU are supposed to be sent sometimes instead of returning success or failure
	* do you need to implement some internal network routing?

	* should you rename vfs_clone_vnode/vfs_release_vnode to instead be vfs_clone_vnode_ref/vfs_drop_vnode_ref ??  The latter would make more sense, albeit be longer
	* move interrupts.c/h to its own arch dir somewhere.  It contains the last m68k specific assembly, but requires a subdir in src/kernel for the code, along with the syscall_entry.s and start.s files
	* you could possibly make an abstracted packet construction thing using an ioctl-like function defined for each protocol, which can intercept parts of
	  the requests to fill in data in the packet headers (set src address, set dest address, add id, etc)


	* implement dns
	* add pipe setup to command evaluation
	* add the & (run in background) option to the shell
	* add support for * in shell
	* make a simple web server
	* add fifos (should be easy now)
	* implement unix domain sockets
	* add stack guard protection
	* implement login system (setuid)
	* implement fcntl
	* implement symlinks in minixfs
	* optionally implement ftell, fgetpos, fsetpos
	* can you implement some kind of terminal switching, like alt-F* keys... It would have to be more like `screen`
	* make a /dev/flash0 device or /dev/rom0 device in the mem.c driver, possibly even with a partition table and bootloader, that can be mounted read only
	* port some kind of interpreter, like scheme
	* try porting a simple command, and then something more complex, maybe awk or something as a big target

	* implement fg/bg somehow... it would be builtin to the shell and would require job control stuff...
	* add commands: rmdir, dd, chown, grep
	* implement shell scripting?
	* add up/down arrow processing to the shell (easy without cooked input, but how would it be done with...)
	* add some kind of debugging or tracing support
	* make a PIE format that can be loaded and executed (this will likely require a custom linker script)



	* should there be a lighter weight task type, instead of processes, so that you can service interrupt processing without a bunch of wasted memory
	* should you add timestamps to packets? (not currently a use for it)
	* rewrite the math functions to use fewer registers, and cover the 32 bit divide by 32 bit number case
	* minixfs, implement versions 2 and 3
	* implement links for mallocfs
	* should you refactor the header files in minixfs implementation into actual c files, with a common header to declare the functions?
	* do you need to add variable sized buffers/blocks into bufcache? (yes)
	* can you change the fd allocator, such that calling it twice will return 2 different fds, even though they aren't reserved until set
	  (ie. store the last allocated fd, but it has to be in the process struct)


	* remove the execbuiltin syscall, which is temporary until all commands can be executable files


	* there is an issue running the shell on linux related to the setting the process group
	* could you use the queue node to add procs to a free list, instead of iterating over all the procs when creating a new one
	* the return from syscalls is sometimes generating a move %d0, %d1; move %d1, %d0
	* re-evaluate file permissions checks to make sure they're correct according to posix
	* you need some tests, but ideally it would use a simple emulator.  Maybe easy68k or something could be used
	* It *might* be possible to defer the context save until you're certain a reschedule is needed just before exiting, but it would require being very careful during the stack swap

	* as a note about terminology for pseudoterminals, pts/ptm (slave/master);  it would make more sense for them to be named process-end and device-end, which implies
	  the expected interface to each.   A user process will open the process-end terminal device and communicate with it like any tty.  The emulator or whatever would
	  connect to the other end and act as if it were a terminal device, in place of what would be an actual I/O device like RS-232 or a hardwired keyboard.  I guess the
	  abbreviations might be /dev/ptpX and /dev/ptdX?


Monitor:

	* failure vectors don't point to the correct addresses, from the looks of it

	* can you have an debugger in the monitor software?  There are trap and breakpoint instructions in the processor for debugging, so if you define an interrupt handler
	  for those, you could have it enter a debugger, that possibly allows single stepping?  I'm not sure how to implement that


68k Single Board Computer:

	* the serial issue turns out to be a problem with the crystal for the serial chip.  It is outputting an inconsistent signal around 100kHz when powered through
	  USB or power supply.  When powered by the arduino, you have to unplug and replug the serial usb cable to make it work, which seems to reset the oscillator.
	  Connecting a 22pF capacitor across the crystal jumpstarts it, but the output is a lot lower on the scope with it connected.  The datasheet says to use 15 and 5pF
	  which is pretty low, and I don't have caps that small.  I have to play with it more, but this seems to be a cap issue more than anything


	* can you add a video/lcd expansion via the expansion connector?  Maybe you could get ends to directly connect it?  Would it be via parallel interface?
	  would you need a PIT 68230 to interface?  How complex are the interfaces of those graphic ones?
	* can you connect an esp01 as a wifi device?  I suppose you could connect it to the other serial port, even though it would be slow


68k Arduino Shield:
	(nothing atm)


68k SMT:
	(nothing atm)


* should you move the Z80 project into it's own repo?

