
Operating System:

	* add a check_pending_signals() function to run after unblocking
	* add means of sending a signal to a process group, and add syscall support for it

	* factor out a sched.h interface that can cover most needs inside the proc module
	* there needs to be a lot of refactoring with the signals code about what goes where... the need for splitting processes and scheduling is even greater now
	* there is a problem with the user signal handlers on ^C such that the signal is dispatched right away, and the context and state of the proc changed, but then after
	  that, the tty driver tries to resume procs, but since the state is changed, this doesn't have an affect and it's not until another character is entered that both the
	  ^C and the other character are read (and the prompt is only then printed).

	* need to add the various checks related to foreground pgid and ctty (and signals) such that you have to be in the same session, or something, and SIGTTOU is sent sometimes
	  instead of returning success or failure
	* it seems like in minix, an interrupt occurs, and a tty event message is placed on a queue, which is handled by a loop in the tty driver task which is its own process.
	  that calls a hook in the tty device struct which points to one of the hardware driver's functions, which reads the character and then directly calls in_process() to do
	  cannonical processing, from which a SIGINT can be dispatched to the process group recorded in the tty struct (as well as echo the char and such), and all that while the
	  process that receives the sigint isn't doing i/o on the tty where the ^C originates....  This is all before the data is placed in a buffer, which wont be returned to the
	  process that reads it until an entire line is entered
	* implement signal handlers
	* make sure init is process id 1... you might need to reserve pids if you end up creating a background task for the kernel

	* driver access through the filesystem is broken because it doesn't give an offset to the driver.  It should be possible to track the position
	  in the file->position value (which isn't passed to the driver), but since file->vnode->size is not set, seeking wont work anyways (will always reset to 0)
	  It looks like linux passes an offset pointer to the read/write functions, which the driver function adjusts by deref'ing
	* we could also move them to the vfs functions...


	* make a device-independent tty subsystem
	* need to set the ctty in the init process somehow (other systems set it as a special case when opening a tty)
	* syscalls to implement: setuid
	* add updating of fs timestamps, should they be in vfs or inside individual implementations?
	* minixfs: fix vnode cache to limit in-memory storage to a fixed number of nodes before offloading
	* change the blocking/waiting code to use either of the state enums for blocking or waiting, rather than checking that the syscall is wait or waitpid
	* make it possible to sync disk data to flash (possibly even to write new monitor roms to flash as well)
	* implement gmtime() and make the time command return a formatted time


	* add commands: ps, kill
	* what is needed to implement a 'ps' command in userspace? pstat()

	* implement getopt
	* add commands: mv, cp, rmdir, pwd, dd
	* implement links and/or symlinks in minix filesystem
	* need to remove the current_proc_stack value, instead writing directly to the process struct


	* should the signal dispatcher somehow reschedule the process to run next, so that it handles it as soon as possible?
	* should the default signal actions be handled right away instead of separately (in another system process or some other way)?


	* add pipe setup to command evaluation
	* add network syscalls for local IPC (unix file, sockets, maybe even fifos?)
	* make a background process of some kind, perhaps launched by init, but I don't know what it could do since there are no other devices yet...

	* get flow control working in the serial driver (might require allowing interrupts without task switching while processing syscalls)
	* minixfs, implement versions 2 and 3

	* should there be something that periodically syncs data to disk?
	* should you refactor the header files in minix implementation into actual c files, with a common header to declare the functions?
	* should there be a vnode op to fill in the statbuf struct, or should they be in the vnode?  The 3 values not in the vnode (ino, blksize, blocks)



	* look for any bugs that might be caused by a function returning the same vnode as was passed in
	* minixfs: add endian-conversion for superblock/inode/etc values, to be truely compatible

	* remove the execbuiltin syscall, which is temporary until all commands can be executable files


	* do you need to add variable sized buffers/blocks into bufcache? (yes)
	* re-evaluate file permissions checks to make sure they're correct according to posix
	* move interrupt and syscall_entry code into proc??


	* should you make a lib subdir, and put unistd at the top?
	* move the math functions in libc to arch/68k
	* move as much inline assembly, from headers especially, into a redirectable asm directory
	* can you change the fd allocator, such that calling it twice will return 2 different fds, even though they aren't reserved until set
	  (ie. store the last allocated fd, but it has to be in the process struct)

	* add brk/sbrk/stack guard protection
	* a slab allocator would maybe help, but I don't think it's as important at the moment
	* a page allocator, to replace the use of malloc for allocating the program space??
	* can you make the kernel relocatable again?
	* rewrite the math functions to use fewer registers
	* you need some tests, but ideally it would use a simple emulator.  Maybe easy68k or something could be used


Monitor:
	* add a help command to print out what commands are available
	* maybe refactor it to use a list of function pointers and names for the command list, like how you've done in sh.c

	* there is an issue with load scripts that are an odd number of bytes, and the last byte wont be read/written because the loader operates on words

	* can you have an debugger in the monitor software?  There are trap and breakpoint instructions in the processor for debugging, so if you define an interrupt handler
	  for those, you could have it enter a debugger, that possibly allows single stepping?  I'm not sure how to implement that


68k Single Board Computer:

	* maybe extra power pins?
	* the serial issue turns out to be a problem with the crystal for the serial chip.  It is outputting an inconsistent signal around 100kHz when powered through
	  USB or power supply.  When powered by the arduino, you have to unplug and replug the serial usb cable to make it work, which seems to reset the oscillator.
	  Connecting a 22pF capacitor across the crystal jumpstarts it, but the output is a lot lower on the scope with it connected.  The datasheet says to use 15 and 5pF
	  which is pretty low, and I don't have caps that small.  I have to play with it more, but this seems to be a cap issue more than anything


	* can you add a video/lcd expansion via the expansion connector?  Maybe you could get ends to directly connect it?  Would it be via parallel interface?
	  would you need a PIT 68230 to interface?  How complex are the interfaces of those graphic ones?
	* can you connect an esp01 as a wifi device?  I suppose you could connect it to the other serial port, even though it would be slow

68k Arduino Shield:
	* maybe extra power pins?



* it might be possible to do a 68030 single board computer, with 74LVC244/245 interfaces to an fpga chip, to provide the glue logic, but it would be a
  lot of surface mount chips, so you'd have to try a few smaller surface mount projects first
* make a surface mount/PLCC version of the 68k-SBC board to test SMT, since the design should work, and some of the memory chips are available as SMT

