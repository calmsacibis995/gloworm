
Operating System:

	* should you pass in the current working dir, or pass it in some other way?
	* need to add some way to update a node's attributes (notify_update() or setattr()?)
	* add file permissions checks, and uid checks
	* add syscalls: mount/umount, dup, chdir, chmod, chown, access, (rmdir?)
	* implement file renaming
	* should the access stuff be entirely in the file system module?
	* add commands: mv, cp, rmdir, pwd, cd

	* add a file pointer duplicate ala vfs_duplicate (to replace directly calling dup_fileptr)
	* move binary file format and arg copying to another file, but where? proc/ mm/ kernel/???
	* there is still one issue with the mallocfs root node, where refcount is 2 instead of just 1

	* add mounting of filesystems, and root node stuff, so you can remove the special case in vfs.c
	* implement minix filesystem

	* implement signals
	* add commands: ps, kill
	* change the blocking/waiting code to use either of the state enums for blocking or waiting, rather than checking that the syscall is wait or waitpid
	* what is needed to implement a 'ps' command in userspace? pstat()
	* sort out process groups, and which process gets input
	* syscalls to implement: getpid, kill, signals, alarm, pause, getuid/setuid, time



	* refactor bufcache into a generic cache data structure which can be used for bufcache as well as vnode cache in minixfs
	* do you need to add variable sized buffers/blocks into bufcache? (yes)
	* make a block driver interface, or should you use a char driver like freebsd does


	* should you make a lib subdir, and put unistd at the top?
	* move the math functions in libc to arch/68k
	* move as much inline assembly, from headers especially, into a redirectable asm directory
	* can you change the fd allocator, such that calling it twice will return 2 different fds, even though they aren't reserved until set
	  (ie. store the last allocated fd, but it has to be in the process struct)

	* add brk/sbrk/stack guard protection
	* a slab allocator would maybe help, but I don't think it's as important at the moment
	* a page allocator, to replace the use of malloc for allocating the program space??
	* can you make the kernel relocatable again?
	* rewrite the math functions to use fewer registers
	* you need some tests, but ideally it would use a simple emulator.  Maybe easy68k or something could be used


Monitor:
	* add a help command to print out what commands are available
	* maybe refactor it to use a list of function pointers and names for the command list, like how you've done in sh.c

	* there is an issue with load scripts that are an odd number of bytes, and the last byte wont be read/written because the loader operates on words

	* can you have an debugger in the monitor software?  There are trap and breakpoint instructions in the processor for debugging, so if you define an interrupt handler
	  for those, you could have it enter a debugger, that possibly allows single stepping?  I'm not sure how to implement that


68k Single Board Computer:

	* maybe extra power pins?
	* the serial issue turns out to be a problem with the crystal for the serial chip.  It is outputting an inconsistent signal around 100kHz when powered through
	  USB or power supply.  When powered by the arduino, you have to unplug and replug the serial usb cable to make it work, which seems to reset the oscillator.
	  Connecting a 22pF capacitor across the crystal jumpstarts it, but the output is a lot lower on the scope with it connected.  The datasheet says to use 15 and 5pF
	  which is pretty low, and I don't have caps that small.  I have to play with it more, but this seems to be a cap issue more than anything


	* can you add a video/lcd expansion via the expansion connector?  Maybe you could get ends to directly connect it?  Would it be via parallel interface?
	  would you need a PIT 68230 to interface?  How complex are the interfaces of those graphic ones?
	* can you connect an esp01 as a wifi device?  I suppose you could connect it to the other serial port, even though it would be slow

68k Arduino Shield:
	* maybe extra power pins?



* it might be possible to do a 68030 single board computer, with 74LVC244/245 interfaces to an fpga chip, to provide the glue logic, but it would be a
  lot of surface mount chips, so you'd have to try a few smaller surface mount projects first
* make a surface mount/PLCC version of the 68k-SBC board to test SMT, since the design should work, and some of the memory chips are available as SMT

