

68k30 SBC:

	* really need to look up the memory interface...  Some other boards are using GALs for the A1/A0, SIZ1-0, and DTACK1-0 logic
	* the idea for rev1 is to clock it slow and have limited features.  1M Flash, 1M SRAM would be sufficient, but if it's not too much trouble to have more...


Operating System:

	* make a command or procfs node to show the current kernel heap size to see if it's growing
	* there's an issue which seems to affect the shell program when run as a normal process, as opposed to the builtin copy the kernel is compiled with.  It seems
	  to affect both the copy sent over serial and the copy transfered by compact flash.  When running commands inside the shell (that's running inside the shell
	  started during boot), it will sometimes say "Command not found" or hang or crash.  Sometimes it'll work without an issue, but sometimes the second command you
	  invoke will hang the system.  This doesn't seems to affect the builtin shell.  Could it be a stack overflow problem? A stack check didn't seem to turn anything up.
	  It seems to happen consistently after starting the shell first thing when booted, and running `ls`, followed by `echo hey`, which halts the system.  The command
	  not found condition seems to be less predictable.  These could be different issues


	* I don't like the implementation of the sh and schedule checking in restore context
	* having an explicit need_sched type flag would handle the timer case, but the syscall return case, as long as it's set by the scheduler's suspend functions
	* when handling a syscall with interrupts on, if a timer interrupt occurs, the call to schedule() could instead of ignoring the switch, schedule the task switch for when
	  the syscall exits (so it does a check when exiting to see if it should switch)
	* look into bottom-half execution in linux, which seems to be run only when exiting a systemcall, but does that also apply to returning from an interrupt that interrupted
	  a user process (as opposed to interrupting the kernel)


	* look at implementation of break and memory stuff in minix. How much memory does it allocate to in the gap?

	* figure out how to boot the system.  Could the flash/ram backed file system get mounted as /boot, with the memory card being mounted as root?  Can it be configurable
	  so that I can boot systems without the flash card?
	* refactor to allow commands to be individually compiled to elfs, and loaded onto the memory card, and executed like normal processes
	* add info to procfs, and fix the cmdline file


	* add a command to set memory locations
	* separate Makefiles so that the kernel can be compiled normally, and commands/libc-68k-os can be compiled with -mpcrel or -fPIE (libc is the big fiddly bit here)
	* make a PIE format that can be loaded and executed

	* move as much inline assembly, from headers especially, into a redirectable asm directory
	* should you make a lib subdir, and put unistd at the top?
	* should the timer stuff in proc be moved somewhere else?
	* the directory size value in the inode isn't working the best.  There is no dir size shrinking yet either

	* make it possible to sync disk data to flash (possibly even to write new monitor roms to flash as well)


	* make a device-independent tty subsystem
	* signals like SIGTTOU are supposed to be sent sometimes instead of returning success or failure
	* need to set the ctty in the init process somehow (other systems set it as a special case when opening a tty)



	* there is a problem with the user signal handlers on ^C such that the signal is dispatched right away, and the context and state of the proc changed, but then after
	  that, the tty driver tries to resume procs, but since the state is changed, this doesn't have an affect and it's not until another character is entered that both the
	  ^C and the other character are read (and the prompt is only then printed).
	* it seems like in minix, an interrupt occurs, and a tty event message is placed on a queue, which is handled by a loop in the tty driver task which is its own process.
	  that calls a hook in the tty device struct which points to one of the hardware driver's functions, which reads the character and then directly calls in_process() to do
	  cannonical processing, from which a SIGINT can be dispatched to the process group recorded in the tty struct (as well as echo the char and such), and all that while the
	  process that receives the sigint isn't doing i/o on the tty where the ^C originates....  This is all before the data is placed in a buffer, which wont be returned to the
	  process that reads it until an entire line is entered
	* should there be a lighter weight task type, instead of processes, so that you can service interrupt processing without a bunch of wasted space for the signals and file
	  descriptor tables...
	* what paradigm should be used to communicated from the interrupts to the scheduled interrupt handling task/process?  Generic IPC messages? A custom event queue (how are event
	  records allocated)?, even just a counter of the number of times an interrupt has occurred.  There could be a burst of hardware interrupts that need to be processed to avoid
	  losing data, but the post-processing takes a lot longer, and needs to queue up fully.  In that sense, just a counter or a bit to say an interrupt is available, and the
	  post-processor can figure out how many events need to be processed, since it's tightly coupled to the hardware interrupt handler


	* get flow control working in the serial driver (might require allowing interrupts without task switching while processing syscalls)
	  perhaps you could use the logic analyzer to look at the interrupt line to see how long it's asserted before the interrupt is handled, to debug the flow control issue
	* add updating of fs timestamps, should they be in vfs or inside individual implementations?
	* implement gmtime() and make the time command return a formatted time


	* add commands: rmdir, pwd, dd, chown
	* implement getopt
	* syscalls to implement: setuid
	* implement login system

	* add support for PATH variables
	* add fifos (should be easy now)
	* make use of 68k's supervisor and user mode (you might not have to switch stacks if you do, since it would use a different stack register)

	* add pipe setup to command evaluation
	* add network syscalls for local IPC (unix file, sockets, maybe even fifos?)
	* should there be something that periodically syncs data to disk?
	* add environment variable substitution to echo command
	* should you refactor the header files in minix implementation into actual c files, with a common header to declare the functions?
	* could I use the queue node to add procs to a free list, instead of iterating over all the procs when creating a new one

	* add check to vfs_link() for loops
	* implement symlinks in minixfs
	* implement links for mallocfs
	* minixfs, implement versions 2 and 3



	* in user processes with pre-initialized global variables, if they contain any addresses, the addresses will be relative to 0, and thus not be correct (rather than being relative addresses)
	* look for any bugs that might be caused by a function returning the same vnode as was passed in
	* should there be a vnode op to fill in the statbuf struct, or should they be in the vnode?  The 3 values not in the vnode (ino, blksize, blocks)

	* remove the execbuiltin syscall, which is temporary until all commands can be executable files

	* do you need to add variable sized buffers/blocks into bufcache? (yes)
	* re-evaluate file permissions checks to make sure they're correct according to posix
	* move interrupt and syscall_entry code into proc??

	* move the math functions in libc to arch/68k
	* can you change the fd allocator, such that calling it twice will return 2 different fds, even though they aren't reserved until set
	  (ie. store the last allocated fd, but it has to be in the process struct)

	* add brk/sbrk/stack guard protection
	* a slab allocator would maybe help, but I don't think it's as important at the moment
	* a page allocator, to replace the use of malloc for allocating the program space??
	* can you make the kernel relocatable again?
	* rewrite the math functions to use fewer registers
	* you need some tests, but ideally it would use a simple emulator.  Maybe easy68k or something could be used

	* as a note about terminology for pseudoterminals, pts/ptm (slave/master);  it would make more sense for them to be named process-end and device-end, which implies
	  the expected interface to each.   A user process will open the process-end terminal device and communicate with it like any tty.  The emulator or whatever would
	  connect to the other end and act as if it were a terminal device, in place of what would be an actual I/O device like RS-232 or a hardwired keyboard.  I guess the
	  abbreviations might be /dev/ptpX and /dev/ptdX?


Monitor:
	* add echoing of characters, backspace, etc
	* add a help command to print out what commands are available
	* maybe refactor it to use a list of function pointers and names for the command list, like how you've done in sh.c

	* there is an issue with load scripts that are an odd number of bytes, and the last byte wont be read/written because the loader operates on words

	* can you have an debugger in the monitor software?  There are trap and breakpoint instructions in the processor for debugging, so if you define an interrupt handler
	  for those, you could have it enter a debugger, that possibly allows single stepping?  I'm not sure how to implement that


68k Single Board Computer:

	* the serial issue turns out to be a problem with the crystal for the serial chip.  It is outputting an inconsistent signal around 100kHz when powered through
	  USB or power supply.  When powered by the arduino, you have to unplug and replug the serial usb cable to make it work, which seems to reset the oscillator.
	  Connecting a 22pF capacitor across the crystal jumpstarts it, but the output is a lot lower on the scope with it connected.  The datasheet says to use 15 and 5pF
	  which is pretty low, and I don't have caps that small.  I have to play with it more, but this seems to be a cap issue more than anything


	* can you add a video/lcd expansion via the expansion connector?  Maybe you could get ends to directly connect it?  Would it be via parallel interface?
	  would you need a PIT 68230 to interface?  How complex are the interfaces of those graphic ones?
	* can you connect an esp01 as a wifi device?  I suppose you could connect it to the other serial port, even though it would be slow

68k Arduino Shield:
	(nothing atm)

68k SMT:
	(nothing atm)


* should you move the Z80 project into it's own repo?

* it might be possible to do a 68030 single board computer, with 74LVC244/245 interfaces to an fpga chip, to provide the glue logic, but it would be a
  lot of surface mount chips, so you'd have to try a few smaller surface mount projects first
* make a surface mount/PLCC version of the 68k-SBC board to test SMT, since the design should work, and some of the memory chips are available as SMT

